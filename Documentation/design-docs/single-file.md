CoreCLR Single-file Publish
Design for publishing apps as a single-file in CoreCLR 3.0

## Solutions

There are several strategies to implement Single-file publishing for CoreCLR apps, with varying cost and benefit. 
The options range from bundling the published files into zip file, to native compiling and linking all the binaries together ([CoreRT](https://github.com/dotnet/corert)). 

The development of the single-file solution in CoreCLR has several stages, as described in this [document](single-file-staging.md)
The rest of this document describes the design of the first stage of development -- the Self-Extractor.

#### Self-Extractor

There are two main aspects to publishing apps as a self-extracting single file:

* The Bundler: A tool that embeds the managed app, its dependencies, and the runtime into a single host executable.
* The host: The "single-file" which extracts the embedded components into temporary files before continuing to execute the app.

## The Bundler

### The Bundling Tool

#### Requirements

The bundler tool must be:

* Able to embed any resource required to run a CoreCLR app -- managed assemblies, native binaries, data files, etc.
* Able to embed a directory hierarchy
* Able to generate cross-platform bundles (ex: publish a single-file for Windows from Unix)
* Deterministic (generate the exact same single-file on multiple runs)

#### Implementation

With the above requirements in mind, we plan to implement a tool similar to [MkBundle](https://github.com/mono/mono/blob/master/mcs/tools/mkbundle) that simply appends the bundled dependencies as a binary blob at the end of a host binary.

To any host (native binary) specified, the bundler tool will add:

* A flag to identify that this is actually a bundle.
* A manifest that declares the directory structure to create and files to extract/populate.
* The actual resources to be bundled.

#### Repository

The bundler tool will be implemented in the CoreCLR Repo within `coreclr/src/tools`

* The tool is best situated close to the core-host, which is slated to move into the CoreCLR  repository.
* This also facilitates using CoreCLR test assets.

### dotnet CLI

We plan to add the following option to dotnet CLI.

`dotnet publish --single-file` 

The `--single-file`switch:

* Causes the managed app, dependencies, configurations, etc (basically the contents of the publish directory when `dotnet publish` is run without the `--single-file` switch) to be embedded within the native `apphost`. The publish directory will only contain single bundled executable.
* Can be with either framework dependent or self-contained publish
* Requires a RID, so there is an apphost to embed dependencies into. 
	* This is technically not a hard requirement, and can be relaxed (ex: Embed dependencies into the managed app itself)
	* But it simplifies the implementation, and is not known to be restrictive.
	
#### Interaction with other tools

Once the `--single-file` tooling is added to the publish pipeline, other static binary transformation tools may need to adapt its presence. For example:

* The MSBuild logic in `dotnet CLI` should be crafted such that `IlLinker`, `Crossgen`, and `Single-file bundler` run in that order in the build/publish sequence. 
* External tools like [Fody](https://github.com/Fody/Fody) that use  `AfterBuild`/`AfterPublish` targets may need to adapt to expect the significantly different output generated by `dotnet --single-file`.  The goal in this case is to provide sufficient documentation and guidance.


#### VS Integration

Developers should be able to use the feature easily from Visual Studio. 

* As an initial/preview step, we can provide a publish-profile for publishing apps as a single-file, which developers can import into their projects and use. 
* Subsequently, we should have first-class inbuilt support in VS for single-file publishing.

## The Host

On Startup, the AppHost checks if it has embedded resources. If so, it 

* Extracts the embedded resources to an *install-location*
* Sets *install-location* as the effective application directory for purposes of the runtime

### Extraction Path

#### Requirements

* Reuse: Extract on first-run, reuse on subsequent runs.
* Fault-tolerance: Recover from failure after partial extraction on first run.
* Upgrade: Each version of the app extracts to a unique location, supporting side-by-side use of multiple versions.
* Uninstall: Users can identify and delete extracted files when the app is no longer needed.
* Access control: Processes running with elevated access can extract to admin-only-writable locations.

#### Implementation

Keeping in mind the above requirements, the AppHost extracts dependencies to `BASE_PATH/APP_NAME/ID/PERM/`

* `BASE_PATH` is 
	* Windows: `%LOCALAPPDATA%\dotnetApps`
	* Linux/Mac: `$HOME/.dotnetApps`
* `APP_NAME` is simple the name of the app (the host executable containing embedded data).
* `ID` is a hash-code based on the host binary to distinguish app version and architecture specifications.
* `PERM` is `user` for normal runs, and `admin` for elevated runs with appropriate write-permissions.
	* There are a few different options for safeguarding elevated runs from using normal-user-writable files.
	* For example:
		* When run with elevated privileges, re-extract to the same location, and set write-restrictions
			* May interfere with a currently running non-previleged instance
		* When run with elevated privileges, verify the contents in-place, and set write-restrictions
			* Need to implement verification logic, need appropriate locking protocols to prevent race-conditions.
		* Use Files extracted by elevated runs for normal runs
			* A non-elevated run trying to write to the install-location may fail.
	* Keeping these constraints in mind, we plan to keep the extraction for normal and privileged runs separate.

If the host fails to extract all the resources at startup, it will attempt to clean up all contents of the install-location before termination.
Subsequent runs will check whether all resources were successfully extracted (via an end-marker).
However, if the contents of install-location are corrupted post-extraction, they will need to be explicitly cleaned.

#### Cleanup

The cleanup of extracted files in the install-location will be manual in this version.
We can consider adding `dotnet CLI` commands for cleanup in future.

### Dependency Resolution

An app may choose to only embed some resources (ex: due to licensing restrictions) and expect to pickup other dependencies from the application-launch directory. To address this situation, the host adds the application launch directory as an additional probing path. By policy, the install-location is always probed first, after which the application-launch directory may be consulted.

## Further Work

### Bundler Optimizations
Since all the files of an app published as a single-file live together, we can perform the following optimizations

* R2R compile the app and all of its dependent assemblies in a single version-bubble
* Investigate whether collectively signing the files in an assembly saves space for certificates.

### Single-file Plugins

The above description only addresses publishing applications as a single-file. In order to support single-file publish for plugins:

* The bundler will mostly work as-is, regardless of whether we publish an application or classlib. The binary blob with dependencies can be appended to both native and managed binaries.
* For extraction, we have two options:
	* Every `Load()` examines whether the binary to be loaded is a plugin, and if so extract it first, or
	* Have new API to load a single-file plugin `AssemblyLoadContext.LoadAssemblyWithEmbeddedDependencies()`.

### `dotnet` CLI options

The following options are likely to be useful in development and testing scenarios:

* Embed more files apart form the publish directory `dotnet publish --single-file --include <dirs>`
* Leave out some files from the single-file `dotnet publish --single-file --exclude <pattern>`

The following options are useful to control the install-location:

* Specify the location to extract embedded resources `dotnet run --extract-to <...> app.exe`
* Cleanup or reinstall extracted resources for an app from the default or specified location:
`dotnet run --cleanup` and `dotnet run --re-extract` 

## Testing

* CoreCLR Test 
	* Add single-file testing as a new mode to run existing tests 
	* There is no plan to implement extraction in the `corerun` host. Therefore, the test infrastructure will need to adapt to using the `dotnet` host for this run. This may preclude using some of the tests.
* End-to-End testing on real world apps: Roslyn, MusicStore

### Measurements

Measure publish size and run-time (first run, subsequent runs) for HelloWorld, Roslyn and MusicStore.

## User Experience

To summarize, the overall the user Experience will be as follows:

* Create a new HelloWorld app: `HelloWorld$ dotnet new console`
* Normal self-contained publish: `dotnet publish -r ubuntu-x64 --self-contained`
	* Creates 217 files including `HelloWorld.dll` in `bin/Debug/netcoreapp2.1/ubuntu-x64/publish/`
* Single-file publish: `dotnet publish -r ubuntu-x64 --self-contained --single-file`
	* Create the one executable file `bin/Debug/netcoreapp2.1/ubuntu-x64/publish/HelloWorld`
* Run: `HelloWorld`
	* Run the app to generate output
	* The 217 embedded files will be extracted to `$HOME/dotnetApps/HelloWorld/h2x345M/user/`
* `rm -r $HOME/dotnetApps/app/`
	* Cleanup the installed dependencies.
	
Most applications are expected to work without any changes. However, apps with a strong expectation about absolute location of dependent or resource files may need to be made aware of bundling and extraction aspects of single-file publishing.

No difference is expected with respect to debugging and analysis of apps.
