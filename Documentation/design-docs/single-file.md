# CoreCLR Single-file Publish

Design for publishing apps as a single-file in .Net-Core 3.0

## Introduction

The goal of this effort is enable .Net-Core apps to be published and distributed as a single executable.

There are several strategies to implement this feature -- ranging from bundling the published files into zip file (ex: [Warp](https://github.com/dgiagio/warp)), to native compiling and linking all the binaries together (ex: [CoreRT](https://github.com/dotnet/corert)). These options, along with their cost/benefit analysis is explored in this [staging document](single-file-staging.md).

In CoreCLR 3.0, we plan to implement a solution that 

* Is widely compatible: Apps containing MSIL assemblies, ready-to-run assemblies, native binaries, configuration files, etc. can be packaged into one executable.
* Can run framework dependent pure managed apps directly from bundle:
  * Executes IL assemblies, and processes configuration files directly from the bundled executable.
  * Extracts ready-to-run and native binaries to disk before loading them.
* Has no degradation in tooling experience: interaction with tools like debuggers, profilers etc. should remain unaffected.

This feature-set is described as Stage 2 in the [staging document](single-file-staging.md), and can be improvised in further releases.

There are two main aspects to publishing apps as a self-extracting single file:

* The Bundler: A tool that embeds the managed app, its dependencies, and the runtime into a single host executable.
* The host: The "single-file" which facilitates the extraction and/or loading of embedded components.

## The Bundler

### Bundling Tool

#### Requirements

The bundler tool must be:

* Able to embed any resource required to run a CoreCLR app -- managed assemblies, native binaries, configuration files, data files, etc.
* Able to generate cross-platform bundles (ex: publish a single-file for Linux target from Windows)
* Deterministic (generate the exact same single-file on multiple runs)

#### Interface

The bundler will be a standalone tool with the following command line:

```CoreCLR Bundler version 0.1
Usage:
bundle.exe -a <App.exe>   The name of the Managed app
           -h <Host.exe>  The path to CoreCLR native host
           -r <resources> The directory containing all resources to embed
          [-o <output>]   The path to output bundle -- defaults to .\bundle\App.exe
          [-v]            Generate verbose output
          [-?]            Display usage information
```

Most users are only expected to interact with the bundler via the dotnet CLI.

#### Implementation

With the above requirements in mind, we plan to implement a tool similar to [MkBundle](https://github.com/mono/mono/blob/master/mcs/tools/mkbundle) that simply appends the bundled dependencies as a binary blob at the end of a host binary.

To any host (native binary) specified, the bundler tool will add:

* A flag to identify that this is actually a bundle.
* A manifest that declares the path (name/relative directory structure) and type (config/IL/native/other) of the bundled resources.
* The actual resources to be bundled.

##### Repository

The bundler should ideally be located close to the dotnet host, since their implementation is closely related. This also facilitates any sharing of headers between the two. Therefore, the bundler will be implemented in the `core-setup` repo.

The host code is expected to move to the CoreCLR repo, at which point, the bundler should move with it. This will facilitate seamless use of CoreCLR test assets.

### dotnet CLI

We propose to add the following option to dotnet CLI.

`dotnet publish --single-file` 

The `--single-file`switch:

* Causes the managed app, dependencies, configurations, etc. (basically the contents of the publish directory when `dotnet publish` is run without the `--single-file` switch) to be embedded within the native `apphost`. The publish directory will only contain the single bundled executable.
* Can be used with either framework dependent or self-contained publish
#### Interaction with other tools

Once the `--single-file` tooling is added to the publish pipeline, other static binary transformation tools may need to adapt its presence. For example:

* The MSBuild logic in `dotnet CLI` should be crafted such that `IlLinker`, `Crossgen`, and `Single-file bundler` run in that order in the build/publish sequence. 
* External tools like [Fody](https://github.com/Fody/Fody) that use  `AfterBuild`/`AfterPublish` targets may need to adapt to expect the significantly different output generated by `dotnet --single-file`.  The goal in this case is to provide sufficient documentation and guidance.


#### VS Integration

Developers should be able to use the feature easily from Visual Studio. 

* As an initial/preview step, we can provide a publish-profile for publishing apps as a single-file, which developers can import into their projects and use. 
* Subsequently, we should have first-class inbuilt support in VS for single-file publishing.

## The Host

On Startup, the AppHost checks if it has embedded resources. If so, it 

* Processes configuration files such as `app.deps.json` , `app.runtimeconfig.json` from the embedded resources, instead of looking for them on the disk next to the app.
* Communicates the location of bundled pure managed assemblies to the runtime, so that they can be loaded on demand.
* Extracts the other resources (native libraries, ready-to-run compiled assemblies, and other data files to an *install-location*).
* Communicates the *install-location* to the runtime, so that it can load binaries from there.

### Resource Extraction

#### Requirements

* Reuse: Extract on first-run, reuse on subsequent runs.
* Fault-tolerance: Recover from failure after partial extraction on first run.
* Upgrade: Each version of the app extracts to a unique location, supporting side-by-side use of multiple versions.
* Uninstall: Users can identify and delete extracted files when the app is no longer needed.
* Access control: Processes running with elevated access can extract to admin-only-writable locations.

#### Implementation

Keeping in mind the above requirements, the AppHost extracts dependencies to `BASE_PATH/APP_NAME/ID/PERM/`

* `BASE_PATH` is 
  * Windows: `%LOCALAPPDATA%\dotnetApps`
  * Linux/Mac: `$HOME/.dotnetApps`
* `APP_NAME` is simple the name of the app (the host executable containing embedded data).
* `ID` is a hash-code based on the host binary to distinguish app version and architecture specifications.
* `PERM` is `user` for normal runs, and `admin` for elevated runs with appropriate write-permissions.

If the host fails to extract all the resources at startup, it will attempt to clean up all contents of the install-location before termination. Subsequent runs will check whether all resources were successfully extracted (via an end-marker). However, if the contents of install-location are corrupted post-extraction, they will need to be explicitly cleaned.

#### Cleanup

The cleanup of extracted files in the install-location will be manual in this version. We can consider adding `dotnet CLI` commands for cleanup in future. However, future versions are expected to spill fewer artifacts to disk, making the cleanup commands a lower priority feature.

### Dependency Resolution

An app may choose to only embed some resources (ex: due to licensing restrictions) and expect to pickup other dependencies from the application-launch directory. To address this situation, the host adds the application launch directory as an additional probing path. By policy, the install-location is always probed first, after which the application-launch directory may be consulted.

## Further Work

### Bundler Optimizations
Since all the files of an app published as a single-file live together, we can perform the following optimizations

* R2R compile the app and all of its dependent assemblies in a single version-bubble
* Investigate whether collectively signing the files in an assembly saves space for certificates.

### Single-file Plugins

The above description only addresses publishing applications as a single-file. In order to support single-file publish for plugins:

* The bundler will mostly work as-is, regardless of whether we publish an application or classlib. The binary blob with dependencies can be appended to both native and managed binaries.
* For extraction, we have two options:
	* Every `Load()` examines whether the binary to be loaded is a plugin, and if so extract it first, or
	* Have new API to load a single-file plugin `AssemblyLoadContext.LoadWithEmbeddedDependencies()`.

### `dotnet` CLI options

The following options are likely to be useful in development and testing scenarios:

* Embed more files apart form the publish directory `dotnet publish --single-file --include <dirs>`
* Leave out some files from the single-file `dotnet publish --single-file --exclude <pattern>`
* At run time, extract all resources to files on disk `dotnet publish --single-file --extract-all`

The following options are useful to control the install-location:

* Specify the location to extract embedded resources `dotnet run --extract-to <...> app.exe`
* Cleanup or reinstall extracted resources for an app from the default or specified location:
  `dotnet run --cleanup` and `dotnet run --re-extract` 

## Testing

* CoreCLR Test 
	* Add single-file testing as a new mode to run existing tests 
	* There is no plan to implement extraction in the `corerun` host. Therefore, the test infrastructure will need to adapt to using the `dotnet` host for this run. This may preclude using some of the tests.
* End-to-End testing on real world apps: Roslyn, MusicStore

### Measurements

Measure publish size and run-time (first run, subsequent runs) for HelloWorld, Roslyn and MusicStore.

## User Experience

To summarize, here's the overall experience for creating a HelloWorld single-file app 

*  Create a new HelloWorld app: `HelloWorld$ dotnet new console`

#### Framework Dependent HelloWorld

* Normal publish: `dotnet publish` 

  Publish directory contains: `HelloWorld.exe` `HelloWorld.dll` `HelloWorld.deps.json` `HelloWorld.runtimeconfig.json` `HelloWorld.pdb`

* Single-file publish: `dotnet publish --single-file`

  Publish directory contains: `HelloWorld.exe` `HelloWorld.pdb`

* Run: `HelloWorld.exe`

  The app runs completely from the single-exe, without the need for intermediate extraction to file.

#### Self-Contained HelloWorld

- Normal publish: `dotnet publish -r ubuntu-x64 --self-contained`

  - Publish directory contains 221 files including the app and the runtime.

- Single-file publish: `dotnet publish -r ubuntu-x64 --self-contained --single-file`

  - Publish directory contains: `HelloWorld.exe` `HelloWorld.pdb`

- Run: `HelloWorld.exe`

  The embedded native and ready-to-run binaries files will be extracted to `$HOME/dotnetApps/HelloWorld/h2x345M/user/`

- To clean up the extracted dependencies `rm -r $HOME/dotnetApps/app/`

Most applications are expected to work without any changes. However, apps with a strong expectation about absolute location of dependent or resource files may need to be made aware of bundling and extraction aspects of single-file publishing. No difference is expected with respect to debugging and analysis of apps.